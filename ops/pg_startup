#!/bin/bash

# Recommended for dev/demo use only! Production uses external database

function wait_for_ready() {
    timer=${1:-15}
    until runuser -l postgres -c 'pg_isready' 2>/dev/null; do
        >&2 echo "[$(date -d %Y-%m-%d\ %H:%M:%S)] Postgres is unavailable - sleeping for $timer seconds"
        sleep $timer
    done
}

function shutdown() {
    echo "Shutting down PostgreSQL"
    pkill postgres
}

# Allow any signal which would kill a process to stop PostgreSQL using the 'shutdown' function
# KILL goes directly to kernel, so it's useless here.
trap shutdown HUP INT QUIT ABRT ALRM TERM TSTP
PG_BIN=/usr/lib/postgresql/11/bin

if [ "$1" = "init" ]; then
    # This is run once, usually in the docker build process. If run a second time, creating the root user will fail.
    # It creates the postgres data directory ($PGDATA) and initial db files, starts the server, and then loads
    # the UTA data from the tarball.
    #
    # After that is complete, we make sure to shutdown postgres gently. Some shutdown modes will put postgres in bad
    # state, causing restarts to take a long time (replay of xlog/transaction logs)

    echo "Init of Postgres cluster in $PGDATA"
    mkdir -p $PGDATA
    cp /anno/ops/postgresql.conf $PGDATA/
    chown -R postgres $PGDATA

    if [ -d "$PGDATA/pg_clog" ]; then
       echo "The database data dir already exists."
    else
        echo "Creating database cluster in $PGDATA"
        gosu postgres $PG_BIN/initdb
    fi

    # default superuser/password, change to something private after install
    gosu postgres $PG_BIN/postgres --single -jE <<-EOSQL
       CREATE USER root WITH SUPERUSER PASSWORD 'omgenetics' ;
EOSQL

    echo "Starting PostgreSQL"
    $PG_BIN/postgres &
    wait_for_ready # make sure postgres has started before loading data

    echo "Extracting database from dump"
    dropdb uta
    dropuser uta_admin
    createuser -U postgres uta_admin
    createdb -U postgres -O uta_admin uta
    gzip -cdq /$UTA_VERSION.pgd.gz | psql -q -U uta_admin -1 -v ON_ERROR_STOP=1 -d uta
    echo "Refreshing materialized views"
    psql -U uta_admin -d uta -c "REFRESH MATERIALIZED VIEW ${UTA_VERSION}.exon_set_exons_fp_mv;"
    psql -U uta_admin -d uta -c "REFRESH MATERIALIZED VIEW ${UTA_VERSION}.tx_exon_set_summary_mv;"
    psql -U uta_admin -d uta -c "REFRESH MATERIALIZED VIEW ${UTA_VERSION}.tx_def_summary_mv;"
    # wait for all the actions to finish and postgres to return to a good state and shut it down cleanly
    wait_for_ready 5
    shutdown
    touch $PGDATA/pgready
    rm /$UTA_VERSION.pgd.gz
    echo "Database ready"
else
    echo "Starting PostgreSQL"
    # if not running in singularity container, use gosu for postgres user
    if [[ -z $SINGULARITY_NAME ]]; then
        exec gosu postgres $PG_BIN/postgres
    else
        exec $PG_BIN/postgres
    fi
fi
